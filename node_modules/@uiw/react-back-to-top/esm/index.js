import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
var _excluded = ["className", "prefixCls", "element", "top", "size", "strokeWidth", "smooth", "hideProgress", "children"];
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { jsx as _jsx } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime";
var warpperStyle = {
  position: 'sticky',
  bottom: 15,
  right: 15,
  visibility: 'visible',
  opacity: 0,
  transition: 'visibility 0.3s linear 0s, opacity 0.3s linear 0s',
  cursor: 'pointer',
  userSelect: 'none'
};
var svgStyle = {
  display: 'block',
  transform: 'rotate(-90deg)'
};
var circleStyle = {
  transition: 'stroke-dashoffset 0.3s linear 0s'
};
var childStyle = {
  position: 'absolute',
  top: 0,
  display: 'flex',
  height: '100%',
  width: '100%',
  alignItems: 'center',
  justifyContent: 'center',
  color: '#fff',
  fontSize: 12
};
var documentElement = document.documentElement;
export default function BackToUp(props) {
  if (props === void 0) {
    props = {};
  }
  var {
      className,
      prefixCls = 'w-back-to-up',
      element = documentElement,
      top = 120,
      size = 35,
      strokeWidth = 3,
      smooth = true,
      hideProgress = false,
      children
    } = props,
    others = _objectWithoutPropertiesLoose(props, _excluded);
  var $dom = useRef(null);
  var cls = [className, prefixCls].filter(Boolean).join(' ');
  var style = Object.assign({}, warpperStyle, {
    position: element === documentElement ? 'fixed' : 'sticky'
  }, others.style, {
    width: size,
    height: size,
    opacity: top === 0 ? 1 : 0
  });
  var center = useMemo(() => size / 2, [size]);
  var radius = useMemo(() => size / 2 - strokeWidth / 2, [size, strokeWidth]);
  var dasharray = useMemo(() => Math.PI * radius * 2, [radius]);
  var [progress, setProgress] = useState(dasharray || 0);
  var handleScroll = ev => {
    var {
      clientHeight,
      scrollHeight,
      scrollTop
    } = element || documentElement;
    var percentage = scrollTop / (scrollHeight - clientHeight);
    setProgress(dasharray - dasharray * percentage || 0);
    if ($dom.current && top > 0) {
      $dom.current.style.opacity = scrollTop > top ? '1' : '0';
    }
  };
  useEffect(() => {
    var scrollElement = element === documentElement ? document : element;
    if (scrollElement) {
      scrollElement.addEventListener('scroll', handleScroll, {
        passive: true
      });
    }
    return () => {
      if (scrollElement) {
        scrollElement.removeEventListener('scroll', handleScroll);
      }
    };
  }, [element]);
  var goToUp = ev => {
    element.scrollTo({
      top: 0,
      behavior: smooth ? 'smooth' : 'auto'
    });
  };
  return /*#__PURE__*/_jsxs("div", _extends({
    className: cls,
    ref: $dom
  }, others, {
    onClick: goToUp,
    style: style,
    children: [!hideProgress && /*#__PURE__*/_jsxs("svg", {
      viewBox: "0 0 " + size + " " + size,
      width: size,
      height: size,
      focusable: "false",
      style: svgStyle,
      children: [/*#__PURE__*/_jsx("circle", {
        fill: "rgb(0 0 0 / 75%)",
        stroke: "rgb(200 200 200 / 85%)",
        strokeWidth: strokeWidth,
        r: radius,
        cx: center,
        cy: center
      }), /*#__PURE__*/_jsx("circle", {
        fill: "none",
        stroke: "rgb(0 0 0 / 50%)",
        strokeWidth: strokeWidth,
        r: radius,
        cx: center,
        cy: center,
        strokeDasharray: dasharray,
        strokeDashoffset: progress || 0,
        style: circleStyle
      })]
    }), children && /*#__PURE__*/_jsx("div", {
      style: childStyle,
      children: children
    })]
  }));
}